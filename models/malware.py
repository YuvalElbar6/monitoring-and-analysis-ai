from __future__ import annotations

from datetime import datetime
from datetime import timezone

import psutil
from pydantic import BaseModel
from pydantic import Field


class MalwareIndicators(BaseModel):
    """Specific flags detected by the local behavioral scanner."""
    is_shell_with_network: bool = False
    is_masquerading: bool = False
    is_suspicious_path: bool = False
    is_unrecognized_system_proc: bool = False


class MalwareEvent(BaseModel):
    """
    Structured model for local malware detection events.
    """
    sub_type: str = 'MALWARE_THREAT'
    risk_score: int = Field(ge=0, le=10)

    # Process Context
    pid: int | None = None
    name: str
    exe: str | None = None
    username: str | None = None

    # Intelligence Data
    indicators: MalwareIndicators
    reasons: list[str] = Field(default_factory=list)

    # Internet Intel (Placeholder for VirusTotal/RAG)
    external_reputation: str = 'Pending Lookup'

    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    metadata: dict[str, str] = Field(default_factory=dict)

    @classmethod
    def scan_system_for_threats(cls) -> list[MalwareEvent]:
        """
        Scans all running processes for behavioral red flags.
        """
        threats = []
        for proc in psutil.process_iter(['pid', 'name', 'username', 'exe', 'connections']):
            try:
                info = proc.info
                name = str(info.get('name', '')).lower()
                exe = str(info.get('exe', '')).lower()
                conns = info.get('connections', [])

                score = 0
                reasons = []
                inds = MalwareIndicators()

                # 1. Behavioral Check: Active Shells with Connections
                if any(s in name for s in ['cmd.exe', 'powershell.exe', 'bash', 'nc']) and conns:
                    inds.is_shell_with_network = True
                    score += 7
                    reasons.append(f"Active reverse shell behavior: {name} connected to network.")

                # 2. Path Check: Writable Temp Dirs
                if exe and any(p in exe for p in ['temp', 'tmp', 'appdata']):
                    inds.is_suspicious_path = True
                    score += 3
                    reasons.append(f"Process executing from suspicious writable path: {exe}")

                # 3. Masquerading Check
                if name == 'lsass.exe' and exe and 'system32' not in exe:
                    inds.is_masquerading = True
                    score += 9
                    reasons.append(f"Critical System Process Masquerading: {name} found at {exe}")

                if score > 0:
                    threats.append(
                        cls(
                            risk_score=min(score, 10),
                            pid=info.get('pid'),
                            name=info.get('name') or 'unknown',
                            exe=info.get('exe'),
                            username=info.get('username'),
                            indicators=inds,
                            reasons=reasons,
                            metadata={'scanner': 'local_behavioral_v1'},
                        ),
                    )
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return threats
